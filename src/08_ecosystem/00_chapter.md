# 异步生态系统

Rust 目前仅提供了编写异步代码所需的基础工具。重要的是，执行器、任务、反应器、组合器以及底层 I/O 期物（future）和特征（trait）尚未在标准库中提供。在此期间，由社区提供的异步生态系统填补了这些空白。

异步基础团队（The Async Foundations Team）有兴趣在《Rust异步编程》中扩展示例以涵盖各种运行时。如果你有兴趣为这个项目做出贡献，请通过 [Zulip](https://rust-lang.zulipchat.com/#narrow/stream/201246-wg-async-foundations.2Fbook) 与我们联系。

## 异步运行时

异步运行时是用于执行异步应用程序的库。运行时通常将*反应器*（reactor）与一个或多个*执行器*捆绑在一起。反应器为外部事件（如异步I/O、进程间通信和定时器）提供订阅机制。在异步运行时中，订阅者通常是表示底层I/O操作的期物。执行器负责任务的调度和执行。它们跟踪正在运行和已挂起的任务，轮询期物直到完成，并在任务可以取得进展时唤醒任务。“执行器”这个词经常与“运行时”互换使用。在这里，我们使用“生态系统”一词来描述捆绑了兼容特征和功能的运行时。

## 社区提供的异步板条箱（crate）

### Futures 板条箱

[`futures` 板条箱](https://docs.rs/futures/) 包含了一些在编写异步代码时非常有用的特征和函数，其中包括 `Stream`、`Sink`、`AsyncRead` 和 `AsyncWrite` 特征，以及诸如组合器等实用工具。这些实用工具和特征可能最终会成为标准库的一部分。

`futures` 板条箱有自己的执行器，但没有自己的反应器，因此它不支持异步 I/O 或定时器期物的执行。出于这个原因，它不被视为完整的运行时。一种常见的选择是将 `futures` 中的实用工具与另一个板条箱中的执行器结合使用。

### 流行的异步运行时

标准库中没有异步运行时，官方也没有推荐任何运行时。以下板条箱提供了一些流行的运行时。

- [Tokio](https://docs.rs/tokio/)：一个流行的异步生态系统，包含 HTTP、gRPC 和追踪框架。
- [async-std](https://docs.rs/async-std/)：一个提供标准库组件异步版本的板条箱。
- [smol](https://docs.rs/smol/)：一个小型且简化的异步运行时。提供了 `Async` 特征，可用于包装像 `UnixStream` 或 `TcpListener` 这样的结构体。
- [fuchsia-async](https://fuchsia.googlesource.com/fuchsia/+/master/src/lib/fuchsia-async/)：一个用于 Fuchsia 操作系统的执行器。

## 确定生态系统兼容性

并非所有异步应用程序、框架和库都彼此兼容，或者与每个操作系统或平台兼容。大多数异步代码可以与任何生态系统一起使用，但有些框架和库需要使用特定的生态系统。生态系统的约束并不总是被记录在文档中，但有几个经验法则可以帮助确定某个库、特征或函数是否依赖于特定的生态系统。

任何与异步I/O、计时器、进程间通信或任务交互的异步代码通常依赖于特定的异步执行器或反应器。而其他所有异步代码，如异步表达式、组合子、同步类型和流，在任何嵌套的期物也是生态系统独立的前提下，通常是生态系统独立的。在开始一个项目之前，建议研究相关的异步框架和库，以确保它们与你选择的运行时及其他库兼容。

值得注意的是，`Tokio` 使用 `mio` 反应器并定义了自己的一版异步 I/O 特征，包括 `AsyncRead` 和 `AsyncWrite`。就其本身而言，它与 `async-std` 和 `smol` 不兼容，后者依赖于 [`async-executor` 板条箱](https://docs.rs/async-executor) 以及在 `futures` 中定义的 `AsyncRead` 和 `AsyncWrite` 特征。

冲突的运行时需求有时可以通过兼容层来解决，兼容层允许你在一个运行时中调用为另一个运行时编写的代码。例如，[`async_compat` 板条箱](https://docs.rs/async_compat) 提供了 `Tokio` 与其他运行时之间的兼容层。

暴露异步 API 的库不应依赖于特定的执行器或反应器，除非它们需要生成任务或定义自己的异步 I/O 或计时器期物。理想情况下，只有二进制文件应负责调度和运行任务。

## 单线程与多线程执行器对比

异步执行器可以是单线程或多线程的。例如，`async-executor`板条箱中同时提供了单线程的`LocalExecutor`和多线程的`Executor`。

多线程执行器可以同时推进多个任务的进度。对于包含大量任务的工作负载来说，它可以大大加快执行速度，但在任务之间同步数据的成本通常会更高。因此，在选择单线程或多线程运行时时，建议为你的应用程序进行性能测试。

任务可以在创建它们的线程上运行，也可以在单独的线程上运行。异步运行时通常提供将任务生成到单独线程上的功能。即使任务在单独的线程上执行，它们仍然应该是非阻塞的。为了在多线程执行器上调度任务，这些任务还必须是`Send`的。一些运行时提供了生成非`Send`任务的函数，这确保每个任务都在生成它的线程上执行。运行时还可能提供将阻塞任务生成到专用线程上的函数，这在运行来自其他库的阻塞同步代码时非常有用。
